class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for p in nums:
            if p == 2:
                ans.append(-1)
                continue
            
            # count number of trailing ones in binary representation of p
            s = 0
            tmp = p
            while tmp & 1:
                s += 1
                tmp >>= 1
            
            # k = s - 1
            k = s - 1
            # a = p - 2^k
            a = p - (1 << k)
            ans.append(a)
        
        return ans

"""
Approach & Reasoning:
We need, for each prime p = nums[i], the smallest integer a such that:
    a OR (a + 1) == p
or return -1 if impossible.

Key bit property:
Let k be the index of the least significant 0-bit in a.
Then bits [0..k-1] in a are all 1, bit k in a is 0, and adding 1 flips:
- bits [0..k-1] -> 0
- bit k -> 1
- higher bits unchanged
Therefore, (a OR (a+1)) will always have bits [0..k] all equal to 1, and higher bits equal to a.
So p must look like: “some prefix” + “a suffix of (k+1) ones”.

In particular, p is always odd. Hence p = 2 is impossible (the only even prime).

Construction and minimization:
Let s be the number of trailing 1s in p.
Any k in [0..s-1] can work by taking a = p with bit k cleared.
To minimize a, we clear the largest such k (i.e., k = s - 1), because removing a higher power of two
reduces the number the most while preserving the required trailing-ones suffix.

So for p > 2:
- s = countTrailingOnes(p)
- k = s - 1
- a = p - 2^k

Time Complexity: O(n log(max(nums))) (counting trailing ones per number).
Space Complexity: O(1) extra (excluding output).
"""
