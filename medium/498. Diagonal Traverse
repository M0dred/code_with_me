class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        # Use a list to store elements for each diagonal (i + j)
        diagonals = [[] for _ in range(m + n - 1)]
        
        # Group elements by their diagonal index (i + j)
        for i in range(m):
            for j in range(n):
                diagonals[i + j].append(mat[i][j])
        
        result = []
        # Process each diagonal
        for k in range(len(diagonals)):
            # Even-indexed diagonals (0, 2, 4, ...) go up-right, so reverse them
            # Odd-indexed diagonals (1, 3, 5, ...) go down-left, so keep as is
            result.extend(diagonals[k][::-1] if k % 2 == 0 else diagonals[k])
        
        return result

'''
Approach:
1. Group elements by their diagonal index (i + j), where i is the row and j is the column.
2. Create a list of lists to store elements for each diagonal (max diagonal index is m + n - 1).
3. Iterate through the matrix, placing each element mat[i][j] into the diagonal group i + j.
4. Process each diagonal:
   - For even-indexed diagonals, reverse the elements to simulate up-right traversal.
   - For odd-indexed diagonals, keep the order for down-left traversal.
5. Concatenate all diagonal groups to form the result array.

Time Complexity: O(m * n), where m is the number of rows and n is the number of columns. We iterate through each element once to group it and once to build the result.
Space Complexity: O(m * n) for the diagonals list to store elements and the result list (output space may not count toward auxiliary space in some analyses).
'''
