class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        MOD = 10**9 + 7
        # dp[i] represents number of new people who learn the secret on day i
        dp = [0] * (n + 1)
        dp[1] = 1 # First person learns on day 1
       
        # For each day
        for day in range(1, n + 1):
            # For each day after current day within forget period
            for next_day in range(day + delay, min(day + forget, n + 1)):
                # People who learn on day can share after delay until they forget
                dp[next_day] = (dp[next_day] + dp[day]) % MOD
       
        # Sum up all people who know the secret on day n
        result = 0
        for day in range(max(1, n - forget + 1), n + 1):
            result = (result + dp[day]) % MOD
           
        return result
'''
Approach:
The solution tracks the number of people who know a secret on day n, given delay and forget parameters:
1. Use dynamic programming with dp[i] representing new people learning the secret on day i.
2. Initialize dp[1] = 1 as one person learns the secret on day 1.
3. For each day from 1 to n, calculate who can share the secret after delay.
4. For each person who learned on day i, they can share from day i+delay to i+forget-1.
5. Add number of people who learned on day i to dp[next_day] for valid next days.
6. On day n, sum up people who learned the secret in the last 'forget' days.
7. Use modulo 10^9 + 7 for all additions to handle large numbers.
Time Complexity: O(n * forget), where n is the number of days and forget is the forgetting period.
Space Complexity: O(n), for the dp array storing the number of new people per day.
'''
