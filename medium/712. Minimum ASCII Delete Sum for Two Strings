class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        
        # dp[i][j] = minimum ASCII sum of deletions to make s1[0..i) and s2[0..j) equal
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Fill first row: delete all characters from s1 to match empty s2
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        
        # Fill first column: delete all characters from s2 to match empty s1
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    # Characters match → no deletion needed for this pair
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # Delete from s1 or from s2 → take minimum cost
                    delete_s1 = dp[i-1][j] + ord(s1[i-1])
                    delete_s2 = dp[i][j-1] + ord(s2[j-1])
                    dp[i][j] = min(delete_s1, delete_s2)
        
        return dp[m][n]

"""
Approach & Reasoning:
This is a classic dynamic programming problem similar to edit distance, but instead of minimizing operation count, we minimize the sum of ASCII values of deleted characters.

State:
- dp[i][j] = minimum cost (ASCII sum of deleted chars) to make s1[0..i) and s2[0..j) equal

Transitions:
- If s1[i-1] == s2[j-1]: no deletion needed → dp[i][j] = dp[i-1][j-1]
- If different:
  - Delete s1[i-1] → cost += ord(s1[i-1]) → dp[i][j] = dp[i-1][j] + ord(s1[i-1])
  - Delete s2[j-1] → cost += ord(s2[j-1]) → dp[i][j] = dp[i][j-1] + ord(s2[j-1])
  - Take the minimum of the two options

Base cases:
- dp[i][0] = sum of ASCII of s1[0..i) (delete all from s1)
- dp[0][j] = sum of ASCII of s2[0..j) (delete all from s2)

Final answer: dp[m][n]

Time Complexity: O(m × n)
Space Complexity: O(m × n)

This is the standard and optimal DP solution.
"""
