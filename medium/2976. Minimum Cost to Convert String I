from typing import List

class Solution:
    def minimumCost(
        self,
        source: str,
        target: str,
        original: List[str],
        changed: List[str],
        cost: List[int],
    ) -> int:
        INF = 10**18
        ALPHA = 26

        # dist[u][v] = minimum cost to convert char u -> v
        dist = [[INF] * ALPHA for _ in range(ALPHA)]
        for i in range(ALPHA):
            dist[i][i] = 0

        # Multiple edges possible: keep the cheapest
        for o, c, w in zip(original, changed, cost):
            u = ord(o) - ord("a")
            v = ord(c) - ord("a")
            if w < dist[u][v]:
                dist[u][v] = w

        # Floyd-Warshall on 26 letters
        for k in range(ALPHA):
            dk = dist[k]
            for i in range(ALPHA):
                if dist[i][k] == INF:
                    continue
                dik = dist[i][k]
                di = dist[i]
                for j in range(ALPHA):
                    nd = dik + dk[j]
                    if nd < di[j]:
                        di[j] = nd

        total = 0
        for s_ch, t_ch in zip(source, target):
            if s_ch == t_ch:
                continue
            u = ord(s_ch) - ord("a")
            v = ord(t_ch) - ord("a")
            if dist[u][v] == INF:
                return -1
            total += dist[u][v]

        return total


"""
Approach & Reasoning:

Each allowed character change original[i] -> changed[i] with cost[i] forms a directed edge in a graph
over the 26 lowercase letters. We can apply any number of operations, so converting one character may
use a multi-step path (e.g., a -> c -> b). Therefore, for each letter pair (u, v), we need the shortest
path cost from u to v.

Steps:
1) Build a 26×26 distance matrix dist, initialize dist[x][x] = 0 and all others to INF.
2) For every rule (o -> c, w), set dist[o][c] = min(dist[o][c], w) to handle duplicate edges.
3) Run Floyd–Warshall on the 26 letters to compute all-pairs shortest paths.
4) For each position i in source/target:
   - If source[i] == target[i], cost is 0.
   - Otherwise add dist[source[i]][target[i]].
   - If unreachable (INF), return -1.

Time Complexity: O(26^3 + n) ≈ O(n), where n = len(source).
Space Complexity: O(26^2) = O(1) (constant).
"""
