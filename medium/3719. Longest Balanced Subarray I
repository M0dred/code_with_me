from typing import List

class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        best = 0

        for l in range(n):
            evens = set()
            odds = set()
            for r in range(l, n):
                x = nums[r]
                if x & 1:
                    odds.add(x)
                else:
                    evens.add(x)

                if len(evens) == len(odds):
                    best = max(best, r - l + 1)

        return best


"""
Approach & Reasoning:

A subarray is balanced if:
    (# distinct even values) == (# distinct odd values)

Since n <= 1500, we can brute-force all subarrays in O(n^2) while maintaining distinct counts.

For each left boundary l:
- Start with empty sets evens and odds.
- Extend the right boundary r from l to n-1:
  - Insert nums[r] into evens or odds depending on parity.
  - If len(evens) == len(odds), update the answer with (r - l + 1).

Using sets gives O(1) average-time insertion and distinct counting by set size.

Time Complexity: O(n^2)
Space Complexity: O(n) in the worst case for the sets inside one l-loop
"""
