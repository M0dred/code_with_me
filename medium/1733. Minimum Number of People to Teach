class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        # Convert languages to sets for efficient lookup
        languages = [set(lang) for lang in languages]
        
        # Find users in friendships who can't communicate
        users_to_teach = set()
        for u, v in friendships:
            u, v = u - 1, v - 1  # Convert to 0-based indexing
            if not (languages[u] & languages[v]):  # No common language
                users_to_teach.add(u)
                users_to_teach.add(v)
        
        if not users_to_teach:  # All friends can already communicate
            return 0
        
        # Try each language and count how many users need to learn it
        min_teachings = float('inf')
        for lang in range(1, n + 1):
            teachings_needed = 0
            for user in users_to_teach:
                if lang not in languages[user]:
                    teachings_needed += 1
            min_teachings = min(min_teachings, teachings_needed)
        
        return min_teachings
'''
Approach:
The solution finds the minimum number of users to teach a single language so that all friends can communicate:
1. Convert each user's language list to a set for efficient common language checks.
2. Identify friendships where users don't share a common language using set intersection.
3. Collect all users in such friendships into a set (users_to_teach).
4. If no users need teaching (all friends communicate), return 0.
5. For each language from 1 to n, count how many users in users_to_teach don't know it.
6. Return the minimum number of teachings needed across all languages.
Time Complexity: O(m + f * l + u * n), where m is the number of users, f is the number of friendships, l is the average number of languages per user, u is the number of users to teach, and n is the number of languages.
Space Complexity: O(m * l + u), for storing the language sets and the users_to_teach set.
'''
