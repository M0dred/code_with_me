class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        memo = {}
        
        def dp(i: int, j: int) -> int:
            # Base case: less than 3 vertices can't form a triangle
            if j - i < 2:
                return 0
            # Check if already computed
            if (i, j) in memo:
                return memo[(i, j)]
            
            # Try each vertex k to form triangle (i, k, j)
            min_score = float('inf')
            for k in range(i + 1, j):
                score = dp(i, k) + dp(k, j) + values[i] * values[k] * values[j]
                min_score = min(min_score, score)
            
            memo[(i, j)] = min_score
            return min_score
        
        return dp(0, n - 1)

'''
Approach:
- Use top-down dynamic programming with memoization to compute the minimum score.
- Define dp(i, j) as the minimum score for triangulating the sub-polygon from vertex i to j (inclusive).
- Base case: if j - i < 2 (fewer than 3 vertices), return 0 as no triangle can be formed.
- For each sub-polygon [i, j]:
  - Iterate over intermediate vertex k from i+1 to j-1 to form triangle (i, k, j).
  - Compute score as: dp(i, k) + dp(k, j) + values[i] * values[k] * values[j].
  - Take the minimum score over all possible k.
- Memoize results in a dictionary with key (i, j) to avoid recomputation.
- Call dp(0, n-1) to compute the minimum score for the entire polygon.
- Time Complexity: O(n^3), where n is the number of vertices. For each sub-polygon (O(n^2) states), we try O(n) intermediate vertices k.
- Space Complexity: O(n^2) for the memoization dictionary, storing results for each (i, j) pair.
'''
