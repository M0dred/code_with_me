class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        # Check for empty matrix or empty first row
        if not matrix or not matrix[0]:
            return 0
        
        # Get matrix dimensions
        rows, cols = len(matrix), len(matrix[0])
        # Initialize DP table with zeros
        dp = [[0] * cols for _ in range(rows)]
        # Initialize total squares counter
        total_squares = 0
        
        # Iterate through each cell
        for i in range(rows):
            for j in range(cols):
                # Process only cells with value 1
                if matrix[i][j] == 1:
                    # For first row or column, only 1x1 squares are possible
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        # Size of square is min of above, left, and diagonal plus 1
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    # Add number of squares ending at this cell
                    total_squares += dp[i][j]
        
        # Return total count of squares
        return total_squares

'''
Approach:
This solution uses dynamic programming to count all square submatrices with all ones.
1. Initialize a DP table with the same dimensions as the input matrix.
2. For each cell (i, j) with value 1:
   - If in the first row or column, set dp[i][j] = 1 (can only form a 1x1 square).
   - Otherwise, set dp[i][j] to the minimum of the three adjacent cells (above, left, diagonal) plus 1.
3. Sum dp[i][j] for each cell to get the total number of squares, as each dp[i][j] represents
   the number of squares ending at that position.
Time Complexity: O(m * n), where m and n are the dimensions of the matrix.
Space Complexity: O(m * n) for the DP table.
'''
