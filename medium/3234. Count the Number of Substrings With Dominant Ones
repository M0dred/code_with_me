class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        pre = [-1] * (n + 1)
        for i in range(n):
            if i == 0 or s[i - 1] == '0':
                pre[i + 1] = i
            else:
                pre[i + 1] = pre[i]
        res = 0
        for i in range(1, n + 1):
            cnt0 = 1 if s[i - 1] == '0' else 0
            j = i
            while j > 0 and cnt0 * cnt0 <= n:
                cnt1 = (i - pre[j]) - cnt0
                if cnt0 * cnt0 <= cnt1:
                    res += min(j - pre[j], cnt1 - cnt0 * cnt0 + 1)
                j = pre[j]
                cnt0 += 1
        return res

'''
Approach:
- pre[i] stores the rightmost index < i where s[index] == '0', or -1 if none.
- For each ending position i-1, we try increasing number of zeros cnt0.
- Using pre[j], we jump to the position right after the last '0' in the current window.
- cnt1 = total characters in [pre[j], i) minus cnt0 = number of '1's.
- If cnt0*cnt0 <= cnt1, then all substrings ending at i-1 with exactly cnt0 zeros
  and at least cnt0*cnt0 ones are valid.
- The number of such substrings is limited by:
  - How far left we can go: j - pre[j]
  - How many extra '1's we can skip: cnt1 - cnt0*cnt0 + 1
- We take min of both and add to result.

Time Complexity:  O(n) amortized â€” each position is processed a bounded number of times.
Space Complexity: O(n) for the pre array.
'''
