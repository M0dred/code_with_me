class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        # Precompute all squares up to n
        squares = [i * i for i in range(n + 1)]
        
        # For each possible a and b
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                c_sq = squares[a] + squares[b]
                c = int(c_sq ** 0.5)
                # Check if c is integer and c <= n
                if c * c == c_sq and c <= n:
                    count += 1
        
        return count

"""
Approach & Reasoning:

We need to find all (a, b, c) such that:
    a² + b² = c²  and  1 ≤ a, b, c ≤ n

Method:
- Precompute all squares: squares[i] = i²
- For every pair (a, b), compute a² + b²
- Check if the sum is a perfect square (i.e., sqrt(sum) is integer)
- Also check that c = sqrt(a² + b²) ≤ n

This is O(n²) time and O(n) space — perfect since n ≤ 250 → 250² = 62,500 operations.

We use integer square root check: c = int(sqrt(c_sq)), then verify c * c == c_sq

This avoids floating-point precision issues.

Time Complexity : O(n²)
Space Complexity: O(n)
"""
