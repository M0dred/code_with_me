class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        # Sort meetings by time
        meetings.sort(key=lambda m: m[2])
        
        # People who know the secret
        have_secret = {0, firstPerson}
        
        m = len(meetings)
        i = 0
        while i < m:
            curr_time = meetings[i][2]
            # Build graph for all meetings at current time
            graph = defaultdict(list)
            participants = set()
            
            while i < m and meetings[i][2] == curr_time:
                x, y, _ = meetings[i]
                graph[x].append(y)
                graph[y].append(x)
                participants.add(x)
                participants.add(y)
                i += 1
            
            # DFS to spread secret within this time group
            visited = set()
            
            def dfs(person: int):
                visited.add(person)
                have_secret.add(person)
                for neighbor in graph[person]:
                    if neighbor not in visited:
                        dfs(neighbor)
            
            # Start DFS from people who already know the secret and are in this meeting group
            for person in participants:
                if person in have_secret and person not in visited:
                    dfs(person)
        
        return list(have_secret)

"""
Approach & Reasoning:

- Sort meetings by time.
- Initially, person 0 and firstPerson know the secret.
- Process meetings in groups of same timestamp.
- For each group:
  - Build an undirected graph of all people meeting at this time.
  - Use DFS to spread the secret: if any person in the connected component knows the secret,
    the entire component learns it (instantaneous sharing).
- Once a person knows the secret, they keep it forever.

Time Complexity : O(m log m + m) â€” sorting + graph traversal
Space Complexity: O(n + m)
"""
