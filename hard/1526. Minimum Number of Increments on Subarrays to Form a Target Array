from typing import List

class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        # Each operation can raise a whole subarray by 1.
        # The minimal number of ops equals how many times we must "start" a new raise.
        # That's target[0] for the first element plus every positive increase over the previous.
        ops = target[0]
        for i in range(1, len(target)):
            if target[i] > target[i - 1]:
                ops += target[i] - target[i - 1]
        return ops

'''
Approach:
- Think of building target left→right. When target rises from target[i-1] to target[i], we must start (target[i]−target[i−1]) new subarray-increment operations ending at or after i. When it stays same or drops, no new operations are needed.
- Total operations = target[0] + Σ max(0, target[i] − target[i−1]) for i ≥ 1.

Time Complexity:
- O(n), single pass.

Space Complexity:
- O(1), constant extra space.
'''
