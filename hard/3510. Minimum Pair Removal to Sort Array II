from typing import List
import heapq

class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return 0

        val = nums[:]                 # node values (updated in-place)
        prev = [i - 1 for i in range(n)]
        nxt = [i + 1 for i in range(n)]
        nxt[-1] = -1
        alive = [True] * n

        def inv_edge(a: int, b: int) -> int:
            return 1 if (a != -1 and b != -1 and alive[a] and alive[b] and val[a] > val[b]) else 0

        # Count current "inversions" (violations of non-decreasing)
        inv = 0
        for i in range(n - 1):
            if val[i] > val[i + 1]:
                inv += 1

        # Min-heap of (pair_sum, left_index). Tie-break by smallest left_index => leftmost.
        heap = []
        for i in range(n - 1):
            heapq.heappush(heap, (val[i] + val[i + 1], i))

        def valid_pair(i: int) -> bool:
            if i == -1 or not alive[i]:
                return False
            j = nxt[i]
            if j == -1 or not alive[j]:
                return False
            # Ensure adjacency is current and sum matches current values (lazy deletion)
            return prev[j] == i

        ops = 0

        while inv > 0:
            # Extract current minimum-sum adjacent pair (leftmost on ties)
            while heap:
                s, i = heap[0]
                if not valid_pair(i):
                    heapq.heappop(heap)
                    continue
                j = nxt[i]
                if val[i] + val[j] != s:
                    heapq.heappop(heap)
                    continue
                break

            # There will always be a valid pair while length > 1
            s, i = heapq.heappop(heap)
            j = nxt[i]

            pi = prev[i]
            nj = nxt[j]

            # Remove inversion contributions of affected old edges: (pi,i), (i,j), (j,nj)
            inv -= inv_edge(pi, i)
            inv -= inv_edge(i, j)
            inv -= inv_edge(j, nj)

            # Merge j into i
            val[i] = val[i] + val[j]
            alive[j] = False

            # Relink i -> nj
            nxt[i] = nj
            if nj != -1:
                prev[nj] = i

            # Add inversion contributions of new edges: (pi,i), (i,nj)
            inv += inv_edge(pi, i)
            inv += inv_edge(i, nj)

            # Push updated adjacent pair sums for affected pairs
            if pi != -1 and alive[pi]:
                heapq.heappush(heap, (val[pi] + val[i], pi))
            if nj != -1 and alive[nj]:
                heapq.heappush(heap, (val[i] + val[nj], i))

            ops += 1

        return ops


"""
Approach & Reasoning:

The operation is forced each step:
- pick the adjacent pair with the minimum sum (tie → leftmost),
- replace it by their sum.
We must count how many such merges are needed until the array becomes non-decreasing.

To handle n up to 1e5 efficiently, we simulate merges with:
1) A doubly-linked list over indices (prev/nxt arrays + alive flags) so we can delete/merge in O(1).
2) A min-heap of candidate adjacent pairs (pair_sum, left_index) so we can extract the next forced pair
   in O(log n). We use lazy deletion: heap entries are ignored if they no longer represent a current
   adjacent pair.
3) An “inversion count” inv = number of adjacent violations (a > next). The array is non-decreasing
   exactly when inv == 0, so we never need to scan the whole array after each merge.

When merging pair (i, j = nxt[i]):
- Only local edges can change: (prev[i], i), (i, j), (j, nxt[j]).
- We subtract their old inversion contributions, perform the merge, then add the new contributions for
  (prev[i], i) and (i, nxt[j]).
- We also push updated pair sums for newly formed adjacent pairs into the heap.

This matches the exact “minimum-sum, leftmost tie” rule and stops as soon as inv reaches 0.

Time Complexity: O((n + ops) log n) ≤ O(n log n)
Space Complexity: O(n)
"""
