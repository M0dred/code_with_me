from typing import List

class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        ans = 0
        
        def dfs(x: int, fa: int) -> int:
            s = values[x]
            for y in g[x]:
                if y != fa:
                    s += dfs(y, x)  
            nonlocal ans
            ans += s % k == 0          # every subtree whose sum is divisible by k counts as a component
            return s

        dfs(0, -1)
        return ans

"""
Approach & Reasoning:
We perform a post-order DFS (bottom-up). For each node x we compute the total sum s of the subtree rooted at x.

- When s % k == 0, the whole subtree rooted at x forms a valid component that can be separated by cutting the edge to its parent.
- We count every such subtree (including the whole tree when we finish the root).
- Because the problem guarantees that the total sum of the entire tree is divisible by k, the root subtree will always contribute one count.
- Therefore counting every subtree whose sum is divisible by k directly gives the maximum possible number of valid components.

This greedy approach is optimal: we cut the tree whenever a subtree sum is divisible by k, and each such cut increases the component count by 1.

Time Complexity : O(n) – single DFS traversal  
Space Complexity: O(n) – recursion stack + adjacency list
"""
