class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        # Sort points by x-coordinate ascending, then y-coordinate descending
        points.sort(key=lambda p: (p[0], -p[1]))
        count = 0
        n = len(points)
        
        for i in range(n):
            x1, y1 = points[i]  # Alice's position
            # Track max y-coordinate of valid Bob positions to prune checks
            max_y = float('-inf')
            
            for j in range(i + 1, n):
                x2, y2 = points[j]  # Bob's position
                # Since points are sorted by x ascending, x1 <= x2
                # Check if y1 >= y2 (Alice upper-left of Bob)
                if y1 >= y2 and y2 > max_y:
                    valid = True
                    # Check points between i and j for any in or on rectangle
                    for k in range(i + 1, j):
                        x, y = points[k]
                        # Since x1 <= x <= x2 (due to sorting), check y-coordinate
                        if y2 <= y <= y1:
                            valid = False
                            break
                    if valid:
                        count += 1
                        max_y = max(max_y, y2)  # Update max y to prune future checks
        
        return count

"""
Approach:
The optimized solution counts valid pairs (A, B) where Alice at A (x1, y1) is upper-left of Bob at B (x2, y2), and no other points lie within or on the rectangle:
1. Sort points by x-coordinate ascending and y-coordinate descending to ensure x1 <= x2 for i < j and prioritize higher y-coordinates.
2. For each point i as Alice:
   - Iterate over points j > i as Bob.
   - Check if y1 >= y2 (ensuring upper-left condition).
   - Use a max_y variable to prune pairs where y2 is too low (if a valid Bob is found at y2, skip future points with lower y2).
   - For each pair (i, j), check points k between i and j to ensure none lie within or on the rectangle (x1 <= x <= x2, y2 <= y <= y1).
3. If no such point k exists, increment the count.
4. Return the total count.

Time Complexity:
- O(n^2), where n is the number of points. Sorting takes O(n log n), and we iterate over O(n^2) pairs, but the inner check for points k is optimized by:
  - Sorting, which ensures x1 <= x <= x2 for k between i and j.
  - Using max_y to skip invalid Bob positions, reducing redundant checks.
  - In practice, the inner loop is often short due to early termination when a point is found or when max_y prunes candidates.

Space Complexity:
- O(1), as we only use a constant amount of extra space (excluding the input storage), regardless of input size.
"""
