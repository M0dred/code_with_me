import heapq

class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if n == 1:
            return grid[0][0]
        
        # Min-heap: (max_elevation_on_path, row, col)
        heap = [(grid[0][0], 0, 0)]
        visited = set([(0, 0)])
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        max_elevation = grid[0][0]
        
        while heap:
            elevation, r, c = heapq.heappop(heap)
            max_elevation = max(max_elevation, elevation)
            
            # If reached bottom-right, return the max elevation on this path
            if r == n - 1 and c == n - 1:
                return max_elevation
            
            # Explore neighbors
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    heapq.heappush(heap, (grid[nr][nc], nr, nc))
        
        return max_elevation

'''
Approach:
- Use Dijkstra’s algorithm with a min-heap to find the path from (0,0) to (n-1, n-1) with the minimum maximum elevation.
- Initialize a min-heap with the starting cell (grid[0][0], 0, 0) and a visited set with (0, 0).
- Track max_elevation as the maximum elevation encountered on the current path.
- While the heap is not empty:
  - Pop the cell with the smallest elevation.
  - Update max_elevation to the maximum of current max_elevation and the popped cell’s elevation.
  - If the popped cell is (n-1, n-1), return max_elevation as the minimum time.
  - For each unvisited neighbor (up, down, left, right), add it to the heap with its elevation and mark it visited.
- Handle edge case: if n=1, return grid[0][0] as no movement is needed.
- Time Complexity: O(n^2 * log(n^2)) where n is the grid dimension, as each cell is processed once with heap operations costing O(log(n^2)).
- Space Complexity: O(n^2) for the heap and visited set, as all cells may be added to the heap in the worst case.
'''
