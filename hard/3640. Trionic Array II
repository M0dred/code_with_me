from typing import List

class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        NEG = -10**30  # safely below any possible sum

        inc = [NEG] * n   # best sum of a strictly increasing subarray ending at i (length >= 2)
        dec = [NEG] * n   # best sum of an inc-then-dec subarray ending at i (in decreasing phase)
        tri = [NEG] * n   # best sum of an inc-dec-inc subarray ending at i (in final increasing phase)

        for i in range(1, n):
            a, b = nums[i - 1], nums[i]

            # Phase 1: strictly increasing
            if a < b:
                inc[i] = max(inc[i - 1] + b, a + b)

            # Phase 2: strictly decreasing (must come after a valid inc)
            if a > b:
                dec[i] = max(dec[i - 1] + b, inc[i - 1] + b)

            # Phase 3: strictly increasing again (must come after a valid dec)
            if a < b:
                tri[i] = max(tri[i - 1] + b, dec[i - 1] + b)

        return max(tri)


"""
Approach & Reasoning:

A trionic subarray nums[l..r] must have three consecutive phases with strict comparisons:
1) strictly increasing (at least one increasing step),
2) strictly decreasing (at least one decreasing step),
3) strictly increasing (at least one increasing step).

We want the maximum possible sum of any such subarray.

Dynamic programming over the array:
Let each DP state represent the best (maximum) sum of a valid subarray ending at index i.

1) inc[i]:
   Best sum of a strictly increasing subarray ending at i with length >= 2.
   If nums[i-1] < nums[i], we can:
   - extend a previous increasing subarray: inc[i-1] + nums[i]
   - start a new length-2 increasing subarray: nums[i-1] + nums[i]

2) dec[i]:
   Best sum of an “increasing then decreasing” subarray ending at i, currently in the decreasing phase.
   If nums[i-1] > nums[i], we can:
   - extend a previous decreasing phase: dec[i-1] + nums[i]
   - start the decreasing phase from a valid inc ending at i-1: inc[i-1] + nums[i]

3) tri[i]:
   Best sum of a full “inc-dec-inc” trionic subarray ending at i, currently in the final increasing phase.
   If nums[i-1] < nums[i], we can:
   - extend the final increasing phase: tri[i-1] + nums[i]
   - start the final increasing phase from a valid dec ending at i-1: dec[i-1] + nums[i]

The answer is max(tri[i]) over all i, since every tri[i] represents a valid trionic subarray.

Time Complexity: O(n)
Space Complexity: O(n)
"""
