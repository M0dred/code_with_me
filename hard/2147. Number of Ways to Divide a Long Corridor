class Solution:
    def numberOfWays(self, corridor: str) -> int:
        MOD = 10**9 + 7
        n = len(corridor)
        
        # dp[index][seats] = number of ways from index to end with current section having 'seats' seats
        dp = [[-1] * 3 for _ in range(n + 1)]
        
        def count(idx: int, seats: int) -> int:
            if idx == n:
                return 1 if seats == 2 else 0
            
            if dp[idx][seats] != -1:
                return dp[idx][seats]
            
            if seats == 2:
                # Must close current section before proceeding
                if corridor[idx] == 'S':
                    # Start new section with this S
                    res = count(idx + 1, 1)
                else:
                    # Two choices: close now (start new section) or continue current
                    res = (count(idx + 1, 0) + count(idx + 1, 2)) % MOD
            else:
                # Continue current section
                next_seats = seats + 1 if corridor[idx] == 'S' else seats
                res = count(idx + 1, next_seats)
            
            dp[idx][seats] = res
            return res
        
        return count(0, 0)

"""
Approach & Reasoning:

We use top-down DP with memoization.

State:
- idx: current position in corridor
- seats: number of seats in current open section (0, 1, or 2)

Base case:
- When idx == n: valid only if current section has exactly 2 seats

Transition:
- If current section already has 2 seats:
  - Must close it before adding more
  - If current char is 'S' → must start new section (seats = 1)
  - If current char is 'P' → can either close now (start new section, seats=0) or keep current open (seats=2)
- Otherwise: just continue current section, increment seats if 'S'

Time Complexity : O(n) — each state visited once
Space Complexity: O(n) for memoization table
"""
